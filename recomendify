 #!/usr/bin/env python

import sys
import csv
import grafo_aux
from grafo import Grafo


def cargar_datos(ruta_archivo):
    usuarios = set()
    canciones = set()
    usuario_canciones = {}
    cancion_playlists = {}
    
    with open(ruta_archivo, 'r', encoding='utf-8') as archivo:
        lector = csv.DictReader(archivo, delimiter='\t')
        for linea in lector:
            usuario = linea['USER_ID']
            cancion = linea['TRACK_NAME'] + ' - ' + linea['ARTIST']
            playlist = linea['PLAYLIST_NAME']
            
            usuarios.add(usuario)
            canciones.add(cancion)
            
            if usuario not in usuario_canciones:
                usuario_canciones[usuario] = set()
            usuario_canciones[usuario].add(cancion)
            
            if cancion not in cancion_playlists:
                cancion_playlists[cancion] = set()
            cancion_playlists[cancion].add(playlist)
    
    return usuarios, canciones, usuario_canciones, cancion_playlists



def camino(grafo, origen, destino, cancion_playlists):
    if origen not in grafo.grafo or destino not in grafo.grafo:
        print("Tanto el origen como el destino deben ser canciones")
        return
    camino_encontrado = grafo_aux.bfs(grafo, origen, destino, cancion_playlists)
    if camino_encontrado:
        imprimir_camino(camino_encontrado, cancion_playlists)
    else:
        print("No se encontro recorrido")

def imprimir_camino(camino, cancion_playlists):
    resultado = []
    for i in range(len(camino) - 1):
        if i % 2 == 0:  # Canción
            resultado.append(f"{camino[i]} --> aparece en playlist --> {', '.join(cancion_playlists[camino[i]])} --> de -->")
        else:  # Usuario
            resultado.append(f"{camino[i]} --> tiene una playlist -->")
    resultado.append(f"{camino[-1]} --> aparece en playlist --> {', '.join(cancion_playlists[camino[-1]])}")
    print(" ".join(resultado))


def mas_importantes(grafo, n):
    # Implementar la lógica para encontrar las canciones más importantes
    pass

def recomendacion(grafo, tipo, n, canciones):
    # Implementar la lógica para recomendar usuarios o canciones
    pass

def ciclo(grafo, n, cancion):
    # Implementar la lógica para encontrar un ciclo de n canciones
    pass

def rango(grafo, n, cancion):
    # Implementar la lógica para encontrar todas las canciones en rango n
    pass


def construir_grafo(usuarios, canciones, usuario_canciones):
    grafo_bipartito = Grafo()    
    # Construir el grafo bipartito de usuarios y canciones
    for usuario in usuarios:
        grafo_bipartito.agregar_vertice(usuario)
    for cancion in canciones:
        grafo_bipartito.agregar_vertice(cancion)
    for usuario, canciones_usuario in usuario_canciones.items():
        for cancion in canciones_usuario:
            grafo_bipartito.agregar_arista(usuario, cancion)

    return grafo_bipartito


def main():
    if len(sys.argv) < 2:
        print("Ingrese en el formato: ./recomendify <ruta_archivo>")
        return
    
    ruta_archivo = sys.argv[1]
    usuarios, canciones, usuario_canciones = cargar_datos(ruta_archivo)
    grafo_bipartito = construir_grafo(usuarios, canciones, usuario_canciones)
    
    # Leer comandos
    for linea in sys.stdin:
        partes = linea.strip().split(' ')
        comando = partes[0]
        
        if comando == 'camino':
            origen, destino = ' '.join(partes[1:]).split(' >>>> ')
            camino(grafo_bipartito, origen, destino)
        elif comando == 'mas_importantes':
            n = int(partes[1])
            mas_importantes(grafo_bipartito, n)
        elif comando == 'recomendacion':
            tipo = partes[1]
            n = int(partes[2])
            canciones = ' '.join(partes[3:]).split(' >>>> ')
            recomendacion(grafo_bipartito, tipo, n, canciones)
        elif comando == 'ciclo':
            n = int(partes[1])
            cancion = ' '.join(partes[2:])
            ciclo(grafo_bipartito, n, cancion)
        elif comando == 'rango':
            n = int(partes[1])
            cancion = ' '.join(partes[2:])
            rango(grafo_bipartito, n, cancion)
        else:
            print("Comando no reconocido")



if __name__ == "__main__":
    main()